import React, { useEffect, useState, useRef } from "react";
import {
  ActivityIndicator,
  Platform,
  SafeAreaView,
  StyleSheet,
  Text,
  TouchableOpacity,
  View,
} from "react-native";
import MaterialCommunityIcons from "react-native-vector-icons/MaterialCommunityIcons";
import { useNavigation } from "@react-navigation/native";
import { connect } from "react-redux";
import { bindActionCreators } from "redux";
import { GooglePlacesAutocomplete } from "react-native-google-places-autocomplete";

import ReactMap from "../maps/ReactMap";
import { colors } from "../../styles/base";
import {
  checkIfCoordIsStringThenParse,
  checkReduxLastLocation,
  detectEligibility,
  getAddressText,
  getLocales,
  initializeLocation,
  updateReduxLastLocation,
  updateReduxandStorageLastLocation,
} from ".";
import {
  defaultRegion,
  mapplacesplaceholder,
  mapplacespredefinedplaces,
} from "./constants";
import { sentryLog } from "../../sentry";
import {
  defaultlatitude,
  defaultlatitudedelta,
  defaultlongitude,
  defaultlongitudedelta,
  placesAPIkey,
} from "../../axios/constants";

const LocationPin = (props) => {
  const navigation = useNavigation();
  const [location, setLocation] = useState(null);
  const [locationError, setLocationError] = useState(null);
  const [loading, setLoading] = useState(true);
  const [text, setText] = useState(null);
  const [addressText, setAddressText] = useState(null);
  const [regionText, setRegionText] = useState(null);

  const [moving, setMoving] = useState(false);
  const [eligible, setEligible] = useState(false);
  const [initialRegion, setInitialRegion] = useState(null);
  const [region, setRegion] = useState(null);
  const [regionFromPlaces, setRegionFromPlaces] = useState(false);
  const [placesInput, setPlacesInput] = useState("");
  const rbInput = useRef();

  let navData = props.route.params;
  let isNew =
    props.route.params?.isNew || props.route.params?.id === "" ? true : false;

  try {
    useEffect(() => {
      checkLocation();
    }, []);

    useEffect(() => {
      navData = props.route.params;
      console.log("LocationPin navData", navData);
      if (
        navData?.latitude === undefined ||
        navData?.latitude === null ||
        navData?.longitude === undefined ||
        navData?.longitude === null
      ) {
        return;
      }
      setInitialRegion({
        latitude: checkIfCoordIsStringThenParse(navData?.latitude),
        longitude: checkIfCoordIsStringThenParse(navData?.longitude),
        latitudeDelta: 0.01,
        longitudeDelta: 0.01,
      });

      //debug
      /*if (Platform.OS === "android") {
        ToastAndroid.show(JSON.stringify(navData), ToastAndroid.LONG);
      }*/
    }, [props.route.params]);

    useEffect(() => {
      if (location === null) {
        if (initialRegion === null) {
          setInitialRegion(defaultRegion);
        }
        return;
      }

      if (
        navData?.latitude === undefined ||
        navData?.latitude === null ||
        navData?.longitude === undefined ||
        navData?.longitude === null
      ) {
        try {
          if (
            location?.coords === undefined ||
            location?.coords?.latitude === undefined ||
            location?.coords?.longitude === undefined
          ) {
            setInitialRegion(defaultRegion);
          } else {
            setInitialRegion({
              latitude: checkIfCoordIsStringThenParse(
                location?.coords?.latitude
              ),
              longitude: checkIfCoordIsStringThenParse(
                location?.coords?.longitude
              ),
              latitudeDelta: 0.01,
              longitudeDelta: 0.01,
            });
          }
        } catch (err) {
          console.error(err);
          sentryLog(err);
          setInitialRegion(defaultRegion);
        }
      } else {
        return;
      }

      if (region === null) {
        if (location?.coords !== undefined) {
          setRegion(location?.coords);
        }
      }
    }, [location]);

    useEffect(() => {
      const checkReduxLastLocationOnError = async () => {
        let result = await checkReduxLastLocation(props.lastLocation);
        if (result === null) {
          setDefaultRegion();
        } else {
          console.log(
            "using redux LastLocation while locationError",
            locationError
          );
          if (loading) {
            setLoading(false);
          }
          let lastSavedRegion = {
            latitude: defaultlatitude,
            longitude: defaultlongitude,
            latitudeDelta: defaultlatitudedelta,
            longitudeDelta: defaultlongitudedelta,
          };
          try {
            if (
              !(
                result?.latitude === undefined ||
                result?.longitude === undefined ||
                result?.latitude === null ||
                result?.longitude === null
              )
            ) {
              lastSavedRegion = {
                latitude: checkIfCoordIsStringThenParse(result?.latitude),
                longitude: checkIfCoordIsStringThenParse(result?.longitude),
                latitudeDelta: result?.latitudeDelta
                  ? checkIfCoordIsStringThenParse(result?.latitudeDelta)
                  : defaultlatitudedelta,
                longitudeDelta: result?.longitudeDelta
                  ? checkIfCoordIsStringThenParse(result?.longitudeDelta)
                  : defaultlongitudedelta,
              };
            }
          } catch (err) {
            console.error(err);
            sentryLog(err);
          }

          setInitialRegion(lastSavedRegion);
          setRegion(lastSavedRegion);
          if (result?.locale === undefined || result?.locale === null) {
            return;
          }

          setAddressText(result?.locale?.name ? result?.locale?.name : null);
          setRegionText(
            `${result?.locale?.subregion}, ${result?.locale?.region} ${
              result?.locale?.postalCode ? result?.locale?.postalCode : ""
            }`
          );
        }
      };

      const setDefaultRegion = () => {
        setInitialRegion(defaultRegion);
        if (region === null) {
          setRegion(defaultRegion);
        }
        setText(locationError.toString());
      };

      if (locationError === undefined || locationError === null) {
        return;
      }
      if (
        navData?.latitude === undefined ||
        navData?.latitude === null ||
        navData?.longitude === undefined ||
        navData?.longitude === null
      ) {
        checkReduxLastLocationOnError();
      }
      /*if (loading) {
        
      }*/
    }, [locationError]);

    useEffect(() => {
      if (initialRegion === null) {
        return;
      }
      if (loading) {
        setLoading(false);
      }
      setMoving(false);
      console.log("initialRegion", initialRegion);
    }, [initialRegion]);

    useEffect(() => {
      const getLocaleNames = async () => {
        let locales = await getLocales(region);
        console.log("reverseGeocodeAsync", locales);
        if (
          locales === null ||
          locales?.length === undefined ||
          locales?.length < 1
        ) {
          //setText(JSON.stringify(region));
          setEligible(false);
          setAddressText(null);
          setRegionText(null);
          if (locationError === null) {
            updateReduxandStorageLastLocation(props, location?.coords);
          }
        } else {
          if (!regionFromPlaces) {
            setAddressText(getAddressText(locales));
            setRegionText(
              `${locales[0]?.subregion}, ${locales[0]?.region} ${
                locales[0]?.postalCode ? locales[0]?.postalCode : ""
              }`
            );
          }

          const { subregionEligible, regionEligible } = detectEligibility(
            locales[0]?.subregion,
            locales[0]?.region
          );
          if (subregionEligible && regionEligible) {
            setEligible(true);
            if (locationError === null) {
              setText(null);
            }
          } else {
            setEligible(false);
            if (!regionEligible) {
              setText("Provinsi di luar wilayah operasional Home Clinic");
            } else if (!subregionEligible) {
              setText("Kota/Kabupaten di luar wilayah operasional Home Clinic");
            }
          }
          if (
            locationError !== null ||
            locales[0] === undefined ||
            locales[0] === null
          ) {
            console.log("locales number zero", locales[0]);
            return;
          }
          updateReduxandStorageLastLocation(props, {
            ...location.coords,
            locale: locales[0],
          });
        }
      };

      if (
        region === null ||
        region?.latitude === undefined ||
        region?.longitude === undefined
      ) {
        setEligible(false);
        setMoving(false);
        setText("Lokasi tidak terdeteksi. Mohon cek GPS Anda.");
        setAddressText(null);
        setRegionText(null);
        /*if (Platform.OS === "android") {
          ToastAndroid.show(JSON.stringify(region), ToastAndroid.LONG);
        }*/
        return;
      }

      if (moving) {
        if (region === initialRegion) {
          setMoving(false);
        }
      } else {
        getLocaleNames();
      }
    }, [region]);

    const checkLocation = async () => {
      let result = await initializeLocation(6);
      setLocation(result?.location);
      setLocationError(result?.locationError);
    };

    function onRegionChange(e) {
      //setRegion(e);
      if (regionFromPlaces) {
        setRegionFromPlaces(false);
      }
      if (
        initialRegion === null ||
        region === null ||
        initialRegion === region
      ) {
        setMoving(false);
      } else if (!moving) {
        setMoving(true);
      }
    }

    function onRegionChangeComplete(e) {
      setRegion(e);
      setMoving(false);
    }

    function pickPin() {
      navigation.navigate("AddAddress", {
        ...navData,
        ...region,
        fullAddress: addressText
          ? regionFromPlaces
            ? `${addressText},\n${regionText}`
            : addressText
          : isNew || navData?.id === ""
          ? ""
          : navData?.fullAddress,
        pinHeader: regionText
          ? regionText
          : isNew || navData?.id === ""
          ? ""
          : navData?.pinHeader,
        isNew: navData?.id === "" ? (isNew ? isNew : false) : false,
        label:
          navData?.label === undefined ||
          navData?.label === null ||
          navData?.label === "" ||
          regionFromPlaces
            ? addressText
              ? addressText
              : ""
            : navData?.label,
      });
    }

    function setRegionFromPlacesInput(data, detail) {
      //console.log("placesData", data);
      //console.log("placesDetail", detail);
      try {
        if (
          data === undefined ||
          data === null ||
          detail === undefined ||
          detail === null
        ) {
          return;
        }
        setPlacesInput(rbInput.current.getAddressText());

        let geometry = data?.geometry
          ? data?.geometry
          : detail?.geometry
          ? detail?.geometry
          : null;
        console.log("places geometry", geometry);
        if (
          geometry === null ||
          geometry?.location === undefined ||
          geometry?.location === null ||
          geometry?.location?.lat === undefined ||
          geometry?.location?.lng === undefined
        ) {
          return;
        }
        setRegionFromPlaces(true);
        setInitialRegion({
          latitude: checkIfCoordIsStringThenParse(geometry?.location?.lat),
          longitude: checkIfCoordIsStringThenParse(geometry?.location?.lng),
          latitudeDelta: 0.01,
          longitudeDelta: 0.01,
        });

        let newAddressText = data?.description ? data?.description : null;
        if (newAddressText === null) {
          return;
        }

        if (
          data?.structured_formatting === undefined ||
          data?.structured_formatting === null
        ) {
          setAddressText(newAddressText);
          setRegionText(newAddressText);
        } else {
          setAddressText(
            data?.structured_formatting?.main_text
              ? data?.structured_formatting?.main_text
              : newAddressText
          );
          setRegionText(
            data?.structured_formatting?.secondary_text
              ? data?.structured_formatting?.secondary_text
              : newAddressText
          );
        }
      } catch (e) {
        console.error(e);
        sentryLog(e);
      }
    }

    function clearPlacesText() {
      setRegionFromPlacesInput(false);
      setPlacesInput("");
      rbInput.current.setAddressText("");
    }

    return (
      <SafeAreaView style={styles.container}>
        {loading ? (
          <ActivityIndicator size="large" color={colors.splash_blue} />
        ) : (
          <ReactMap
            location={location}
            moving={moving}
            initialRegion={initialRegion}
            regionFromPlaces={regionFromPlaces}
            onRegionChange={(e) => onRegionChange(e)}
            onRegionChangeComplete={(e) => onRegionChangeComplete(e)}
          />
        )}
        <View style={styles.containerTop}>
          <View style={styles.containerHorizontal}>
            <TouchableOpacity
              style={styles.containerBack}
              onPress={() => navigation.goBack()}
            >
              <MaterialCommunityIcons
                name="arrow-left-bold-circle"
                size={32}
                color={colors.light_grey}
                style={{ alignSelf: "center" }}
              />
            </TouchableOpacity>
            <View style={styles.containerTextInput}>
              <GooglePlacesAutocomplete
                ref={rbInput}
                styles={{
                  textInput: styles.textInput,
                }}
                placeholder={mapplacesplaceholder}
                query={{
                  key: placesAPIkey,
                  language: "id",
                  components: "country:ID",
                }}
                predefinedPlaces={mapplacespredefinedplaces}
                fetchDetails={true}
                onPress={(data, detail) => {
                  setRegionFromPlacesInput(data, detail);
                }}
                onFail={(error) => {
                  console.error(error);
                  setText(error.toString());
                }}
              />
              {(placesInput === null || placesInput === "") && !regionFromPlaces ? null : (
                <TouchableOpacity
                  style={styles.close}
                  onPress={() => clearPlacesText()}
                >
                  <MaterialCommunityIcons
                    name="close"
                    color={regionFromPlaces ? colors.splash_blue_light : colors.feed_desc_grey}
                    size={20}
                  />
                </TouchableOpacity>
              )}
            </View>
          </View>
          {text === null ? null : (
            <Text
              style={[
                styles.text,
                {
                  backgroundColor:
                    locationError === null
                      ? eligible
                        ? colors.splash_blue
                        : colors.feed_desc_grey
                      : colors.rusty_red,
                },
              ]}
            >
              {text}
            </Text>
          )}
        </View>

        {loading ? null : (
          <View style={styles.containerInfo}>
            <View style={styles.containerBottom}>
              <Text style={styles.textFullAddress}>
                {moving
                  ? "Pindahkan pin..."
                  : addressText
                  ? addressText
                  : "Lokasi tidak terdeteksi"}
              </Text>
              {moving ? (
                <ActivityIndicator
                  size="small"
                  color={colors.light_grey}
                  style={styles.spinner}
                />
              ) : (
                <Text style={styles.textRegion}>
                  {regionText
                    ? regionText
                    : "Mohon pindahkan pin ke lokasi lain"}
                </Text>
              )}
            </View>
            <TouchableOpacity
              onPress={() => pickPin()}
              style={[
                styles.containerButton,
                {
                  backgroundColor:
                    moving || region === null || !eligible
                      ? colors.feed_desc_grey
                      : colors.pine_green,
                },
              ]}
              disabled={
                (moving || region === null || !eligible) &&
                Platform.OS !== "web"
              }
            >
              <MaterialCommunityIcons
                name="map-marker-check"
                size={16}
                color={colors.light_grey}
              />
              <Text style={styles.textButton}>Pilih Pin Lokasi</Text>
            </TouchableOpacity>
          </View>
        )}
      </SafeAreaView>
    );
  } catch (e) {
    console.error(e);
    sentryLog(e);
    return (
      <SafeAreaView style={styles.container}>
        <Text style={styles.text}>{e.toString()}</Text>
      </SafeAreaView>
    );
  }
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    width: "100%",
    backgroundColor: colors.grey_hint,
    justifyContent: "center",
    alignItems: "center",
  },
  containerTop: {
    position: "absolute",
    zIndex: 5,
    elevation: 6,
    top: 0,
    start: 0,
    width: "100%",
    backgroundColor: colors.splash_blue,
  },
  containerHorizontal: {
    flexDirection: "row",
    backgroundColor: "transparent",
    marginHorizontal: 10,
  },
  containerInfo: {
    position: "absolute",
    zIndex: 3,
    bottom: 0,
    start: 0,
    backgroundColor: "transparent",
    width: "100%",
  },
  containerBack: {
    width: 32,
    height: 32,
    backgroundColor: "transparent",
    marginVertical: 12,
    alignSelf: "flex-start",
  },
  containerTextInput: {
    flex: 1,
    flexDirection: "row",
    backgroundColor: colors.white,
    marginStart: 10,
    marginVertical: 4,
    alignSelf: "center",
    borderRadius: 6,
    alignItems: "center",
  },
  containerBottom: {
    borderRadius: 6,
    borderColor: colors.splash_blue_light,
    borderWidth: 1,
    elevation: 10,
    marginHorizontal: 10,
    backgroundColor: colors.splash_blue,
    paddingVertical: 10,
    paddingHorizontal: 20,
  },
  containerButton: {
    marginHorizontal: 10,
    marginTop: 12,
    marginBottom: 20,
    borderRadius: 6,
    paddingVertical: 10,
    elevation: 10,
    flexDirection: "row",
    alignItems: "center",
    justifyContent: "center",
  },
  text: {
    fontFamily: "Montserrat-Medium",
    fontSize: 12,
    textAlign: "center",
    width: "100%",
    padding: 10,
    elevation: 4,
    color: colors.light_grey,
  },
  textFullAddress: {
    fontFamily: "Montserrat-SemiBold",
    fontSize: 16,
    backgroundColor: "transparent",
    color: colors.light_grey,
  },
  textRegion: {
    fontFamily: "Montserrat-Medium",
    fontSize: 12,
    backgroundColor: "transparent",
    color: colors.light_grey,
    marginTop: 6,
  },
  textButton: {
    fontSize: 16,
    fontFamily: "Montserrat-SemiBold",
    color: colors.light_grey,
    marginStart: 10,
  },
  textInput: {
    flex: 1,
    color: colors.feed_desc_grey,
    backgroundColor: "transparent",
    fontFamily: "Montserrat-Medium",
    paddingHorizontal: 10,
    paddingVertical: 2,
    fontSize: 12,
    marginTop: 2,
    alignSelf: "center",
  },
  close: {
    backgroundColor: "transparent",
    marginStart: 6,
    marginEnd: 10,
    alignSelf: "center",
  },
  spinner: {
    alignSelf: "center",
    marginTop: 10,
  },
});

const mapStateToProps = (store) => ({
  lastLocation: store.locationState.lastLocation,
});

const mapDispatchProps = (dispatch) =>
  bindActionCreators(
    {
      updateReduxLastLocation,
    },
    dispatch
  );

export default connect(mapStateToProps, mapDispatchProps)(LocationPin);
